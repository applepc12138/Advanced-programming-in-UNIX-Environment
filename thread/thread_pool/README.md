###多线程模型:
1. socket和ip地址及端口号绑定，使用accept函数监听此socket套接字，让线程池中的每个线程都阻塞于accept函数上，当有客户端发起连接时，内核将等待在accept函数的所有线程唤醒，线程通过竞争获取任务。
**缺点**:"惊群"效应
2. 设置一个主控线程，主控线程执行accept函数，其他任务线程等待主控线程分配任务。主线程每从accept函数获取一个新的socket描述符，就将其放入到一个任务队列中(全局数组)，再通知线程池中的线程从任务队列获取任务。(生产者消费者模型)
3. 每个线程去争抢一把锁，谁抢到这把锁，谁去执行accept函数。
> pthread_mutex_lock(&mutex);
> accept(listenfd, &clientadd, *clientaddrlen);
> pthread_mutex_unlock(&mutex);
> 处理客户端请求

####管理线程池需要用到的一些变量
- max_thread_num : 线程池中最大线程个数 
- min_thread_num : 线程池中最小线程个数
- cur_thread_num : 当前线程池中线程个数
- cur_work_num : 当前线程池工作线程个数

####当cur_thread_num >> cur_word_num，如何减少线程池中线程个数?
**终止线程方法**:
- pthread_cancel()
- 从线程正常return
- pthread_exit()
- 信号


###线程池工作逻辑
- 工作线程：工作线程主要任务是从任务队列中取一个任务并执行，执行完毕后工作线程重新回到阻塞状态，当任务队列为空时需要阻塞自身
- 管理线程：管理线程控制线程池中线程个数，当线程池中线程数太少时创建若干线程，反之销毁若干线程
- 主线程：主线程需要向线程池添加任务，当任务队列满时还需要阻塞自身。
- 线程池初始化：需要创建若干线程，使其自动运行阻塞在条件变量上
